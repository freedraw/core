var emitter = require('fd/emitter')

function Node() {
  this.parent = null
  this.children = []
  this._name = ''
}
emitter(Node.prototype)
emitter.property(Node.prototype, 'name')

Node.prototype.append = function(child) {
  this.children.push(child.detach())
  child.parent = this
  this.structureChanged([{kind: 'append', parent: this, child: child}])
  return this
}
Node.prototype.appendAll = function(children) {
  var changes = []
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i]
    this.children.push(child.detach())
    child.parent = this
    changes.push({kind: 'append', parent: this, child: child})
  }
  this.structureChanged(changes)
  return this
}
Node.prototype.appendTo = function(parent) {
  parent.children.push(this.detach())
  this.parent = parent
  parent.structureChanged([{kind: 'append', parent: parent, child: this}])
  return this
}
Node.prototype.prepend = function(child) {
  this.children.unshift(child.detach())
  child.parent = this
  this.structureChanged([{kind: 'insert', parent: this, child: child, index: 0}])
  return this
}
Node.prototype.prependTo = function(parent) {
  parent.children.unshift(this.detach())
  this.parent = parent
  parent.structureChanged([{kind: 'insert', parent: parent, child: this, index: 0}])
  return this
}
Node.prototype.addBefore = function(child, reference) {
  if (!reference) return this.append(child)
  if (reference.parent !== this) {
    throw new Error('Reference child does not belong to this node.')
  }

  var i = this.children.indexOf(reference)
  this.children.splice(i, 0, child.detach())

  child.parent = this
  this.structureChanged([{kind: 'insert', parent: this, child: child, index: i}])
  return this
}
Node.prototype.addAfter = function(child, reference) {
  if (!reference) return this.prepend(child)
  if (reference.parent !== this) {
    throw new Error('Reference child does not belong to this node.')
  }

  var i = this.children.indexOf(reference)
  this.children.splice(i + 1, 0, child.detach())

  child.parent = this
  this.structureChanged([{kind: 'insert', parent: this, child: child, index: i + 1}])
  return this
}
Node.prototype.replace = function(old, child) {
  if (old.parent !== this) {
    throw new Error('Child to replace does not belong to this node.')
  }

  old.parent = null
  var i = this.children.indexOf(old)
  this.children[i] = child.detach()

  child.parent = this
  this.structureChanged([{kind: 'replace', parent: this, old: old, child: child}])
  return this
}
Node.prototype.replaceWithAll = function(old, children) {
  if (old.parent !== this) {
    throw new Error('Child to replace does not belong to this node.')
  }

  old.parent = null
  for (var i = children.length; i--;) {
    children[i].detach().parent = this
  }
  var i = this.children.indexOf(old)
  this.children.splice.apply(this.children, [i, 1].concat(children))

  this.structureChanged([{kind: 'replaceWithAll', parent: this, old: old, children: children}])
  return this
}

Node.prototype.detach = function() {
  var parent = this.parent
  if (!parent) return this
  var children = parent.children

  var i = children.indexOf(this)
  if (i === children.length - 1) {
    children.pop()
  } else {
    children.splice(i, 1)
  }

  this.parent = null
  parent.structureChanged([{kind: 'remove', parent: parent, child: this}])
  return this
}

Object.defineProperties(Node.prototype, {
  first: {get: function() {
    return this.children[0]
  }},
  last: {get: function() {
    return this.children[this.children.length - 1]
  }},
  previous: {get: function() {
    var children = this.parent.children
    var i = children.indexOf(this)
    return children[i - 1]
  }},
  next: {get: function() {
    var children = this.parent.children
    var i = children.indexOf(this)
    return children[i + 1]
  }},
  index: {get: function() {
    if (!this.parent) return 0
    return this.parent.children.indexOf(this)
  }},
  root: {get: function() {
    var p = this
    while (p.parent) p = p.parent
    return p
  }},
  ancestors: {get: function() {
    var p = this
    var list = []
    while (p.parent) {
      list.push(p = p.parent)
    }
    return list
  }}
})

Node.prototype.structureChanged = function(changes) {}

module.exports = Node
