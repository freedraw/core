var emitter = require('fd/emitter')

function Node() {
  this.parent = null
  this.children = []
}
emitter(Node.prototype)

Node.prototype.append = function(child) {
  this.children.push(child.detach())
  child.parent = this
  this.structureChanged()
  return this
}
Node.prototype.appendAll = function(children) {
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i]
    this.children.push(child.detach())
    child.parent = this
  }
  this.structureChanged()
  return this
}
Node.prototype.appendTo = function(parent) {
  parent.children.push(this.detach())
  this.parent = parent
  parent.structureChanged()
  return this
}
Node.prototype.prepend = function(child) {
  this.children.unshift(child.detach())
  child.parent = this
  this.structureChanged()
  return this
}
Node.prototype.prependTo = function(parent) {
  parent.children.unshift(this.detach())
  this.parent = parent
  parent.structureChanged()
  return this
}
Node.prototype.addBefore = function(child, reference) {
  if (!reference) return this.append(child)
  if (reference.parent !== this) {
    throw new Error('Reference child does not belong to this node.')
  }

  var i = this.children.indexOf(reference)
  this.children.splice(i, 0, child.detach())

  child.parent = this
  this.structureChanged()
  return this
}
Node.prototype.addAfter = function(child, reference) {
  if (!reference) return this.prepend(child)
  if (reference.parent !== this) {
    throw new Error('Reference child does not belong to this node.')
  }

  var i = this.children.indexOf(reference)
  this.children.splice(i + 1, 0, child.detach())

  child.parent = this
  this.structureChanged()
  return this
}
Node.prototype.replace = function(old, child) {
  if (old.parent !== this) {
    throw new Error('Child to replace does not belong to this node.')
  }

  old.parent = null
  var i = this.children.indexOf(old)
  this.children[i] = child.detach()

  child.parent = this
  this.structureChanged()
  return this
}
Node.prototype.replaceWithAll = function(old, children) {
  if (old.parent !== this) {
    throw new Error('Child to replace does not belong to this node.')
  }

  old.parent = null
  for (var i = children.length; i--;) {
    children[i].detach().parent = this
  }
  var i = this.children.indexOf(old)
  this.children.splice.apply(this.children, [i, 1].concat(children))

  this.structureChanged()
  return this
}

Node.prototype.detach = function() {
  var parent = this.parent
  if (!parent) return this
  var children = parent.children

  var i = children.indexOf(this)
  if (i === children.length - 1) {
    children.pop()
  } else {
    children.splice(i, 1)
  }

  this.parent = null
  parent.structureChanged()
  return this
}

Object.defineProperties(Node.prototype, {
  first: {get: function() {
    return this.children[0]
  }},
  last: {get: function() {
    return this.children[this.children.length - 1]
  }},
  previous: {get: function() {
    var children = this.parent.children
    var i = children.indexOf(this)
    return children[i - 1]
  }},
  next: {get: function() {
    var children = this.parent.children
    var i = children.indexOf(this)
    return children[i + 1]
  }},
  index: {get: function() {
    if (!this.parent) return 0
    return this.parent.children.indexOf(this)
  }},
  root: {get: function() {
    var p = this
    while (p.parent) p = p.parent
    return p
  }},
  ancestors: {get: function() {
    var p = this
    var list = []
    while (p.parent) {
      list.push(p = p.parent)
    }
    return list
  }}
})

Node.prototype.structureChanged = function() {}

module.exports = Node
