var Node = require('./node')
var Matrix = require('fd/matrix')
var Rect = require('fd/rect')
var extend = require('fd/extend')
var inherits = require('fd/inherits')
var property = require('fd/property')
var invalidatingProperty = require('./invalidating-property')

function DisplayNode(props, children) {
  this._transform = Matrix.identity
  this._opacity = 1
  this._hidden = false
  this._blendMode = 'normal'

  Node.call(this)

  if (Array.isArray(props)) {
    children = props
    props = null
  }
  if (props) extend(this, props)
  if (children) this.appendAll(children)
}
inherits(DisplayNode, Node)

DisplayNode.prototype.isGroup = false
DisplayNode.prototype.isShape = false

property(DisplayNode.prototype, 'localToGlobal', {get: function() {
  var transform = Matrix.identity
  var node = this
  do {
    transform = node.transform.concat(transform)
  } while (node = node.parent)
  return transform
}})
property(DisplayNode.prototype, 'globalToLocal', {get: function() {
  return this.localToGlobal.inverse
}})

property(DisplayNode.prototype, 'boundingBox', {
  get: function() {
    if (this.cachedBoundingBox) return this.cachedBoundingBox

    var bb = this.ownBoundingBox()
    for (var i = this.children.length; i--;) {
      var c = this.children[i]
      if (c.hidden) continue
      bb = bb.union(c.boundingBox.transform(c.transform))
    }
    return this.cachedBoundingBox = bb
  },
  set: function(bb) {
    if (this.cachedBoundingBox && bb.equals(this.cachedBoundingBox)) return
    this.updateBoundingBoxFrom(bb)
    this.boundingBoxChanged()
  }
})
DisplayNode.prototype.ownBoundingBox = function() {
  return Rect.zero
}
DisplayNode.prototype.boundingBoxChanged = function() {
  if (!this.cachedBoundingBox) return
  this.cachedBoundingBox = null
  if (this.parent) this.parent.boundingBoxChanged()
  this.didChange()
}
DisplayNode.prototype.updateBoundingBoxFrom = function(bb) {
  var old = this.boundingBox
  for (var i = this.children.length; i--;) {
    var c = this.children[i]
    c.boundingBox = c.boundingBox.rescale(old, bb)
  }
}

DisplayNode.prototype.structureChanged = function() {
  this.boundingBoxChanged()
  this.invalidate()
}
DisplayNode.prototype.didChange = function() {
  this.emitThrottled('change')
  this.invalidate()
}
DisplayNode.prototype.invalidate = function() {
  var r = this.root
  if (r.isDocument) r.emitThrottled('invalidate')
}
invalidatingProperty(DisplayNode.prototype, 'transform')
invalidatingProperty(DisplayNode.prototype, 'opacity')
invalidatingProperty(DisplayNode.prototype, 'blendMode')
property(DisplayNode.prototype, 'hidden', {didSet: function() {
  if (this.parent) this.parent.structureChanged()
  this.emitThrottled('hiddenChange')
  this.didChange()
}})

DisplayNode.prototype.pathOn = function(cx) {
  this.boundingBox.pathOn(cx)
}
DisplayNode.prototype.isSolidAt = function(p) {
  return this.boundingBox.includes(p)
}
DisplayNode.prototype.drawOn = function(cx) {}
DisplayNode.prototype.drawTreeOn = function(cx) {
  if (this.hidden) return
  cx.save()
  this.transform.transformContext(cx)
  if (this._opacity !== 1 || this._blendMode !== 'normal') {
    var mat = cx.currentTransform
    var canvas = this._tempCanvas || (this._tempCanvas = document.createElement('canvas'))
    var bb = this.boundingBox
    var tcx = canvas.getContext('2d')
    var scaleX = mat.a
    var scaleY = mat.d
    canvas.width = bb.width * scaleX
    canvas.height = bb.height * scaleY
    tcx.scale(scaleX, scaleY)
    tcx.translate(-bb.x, -bb.y)
  } else {
    var tcx = cx
  }
  this.drawOn(tcx)
  for (var i = 0, l = this.children.length; i < l; i++) {
    this.children[i].drawTreeOn(tcx)
  }
  if (tcx !== cx) {
    cx.globalAlpha = this._opacity
    cx.globalCompositeOperation = this._blendMode
    cx.drawImage(canvas, bb.x, bb.y, bb.width, bb.height)
  }
  cx.restore()
}

DisplayNode.prototype.nodeAt = function(p) {
  if (this.hidden) return null
  for (var i = this.children.length; i--;) {
    var c = this.children[i]
    if (c.transform.determinant === 0) return false
    var q = p.transform(c.transform.inverse)
    var n = c.nodeAt(q)
    if (n) return n
  }
  return this.isSolidAt(p) ? this : null
}
DisplayNode.prototype.childAt = function(p) {
  for (var i = this.children.length; i--;) {
    var c = this.children[i]
    if (c.transform.determinant === 0) return false
    var q = p.transform(c.transform.inverse)
    if (c.isSolidAt(q)) return c
  }
  return null
}
DisplayNode.prototype.siblingAt = function(p) {
  if (!this.parent) return false

  var q = p.transform(this.transform)
  var children = this.parent.children
  for (var i = children.length; i--;) {
    var c = children[i]
    if (c.hidden) continue
    if (c === this && this.isSolidAt(p)) return null
    if (c.transform.determinant === 0) return false
    var r = q.transform(c.transform.inverse)
    if (c.isSolidAt(r)) return c
  }

  return null
}

DisplayNode.prototype.ancestorSiblingAt = function(p) {
  return this.siblingAt(p) || this.parent && this.parent.ancestorSiblingAt(p.transform(this.transform))
}

module.exports = DisplayNode
