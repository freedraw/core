var h = require('fd/html')
var property = require('fd/property')

function Node(tree, parent, model) {
  this.tree = tree
  this.parent = parent
  this.model = model
  this.open = false
  this.loaded = false
  this.children = null
  this._selected = false

  this.el = h('.node', [
    this.item = h('.item', [
      this.disclosureButton = model.isGroup ? h('button.disclosure') : h('.disclosure placeholder'),
      this.icon = h('.icon'),
      this.title = h('.title'),
      this.lock = h('button.lock'),
      this.hide = h('button.hide'),
    ]),
    this.container = h('.children'),
  ])

  this.updateIcon()
  this.updateTitle()
  this.updateHidden()

  model.on('nameChange', this.updateName)
  model.on('hiddenChange', this.updateHidden)
  this.disclosureButton.addEventListener('click', this.onDisclosureClick.bind(this))
  this.item.addEventListener('mousedown', this.onClick.bind(this))

  tree.nodes.set(model, this)
}

Node.prototype.updateIcon = function() {}
Node.prototype.updateTitle = function() {
  this.title.textContent = this.model.name
}
Node.prototype.updateHidden = function() {}

Node.prototype.onDisclosureClick = function() {
  this.toggle()
}
Node.prototype.onClick = function(e) {
  if (this.model.isGroup && e.target === this.disclosureButton) return
  this.tree.editor.selection = this.model
}

Node.prototype.update = function(c) {
  if (!this.loaded) return
  switch (c.kind) {
    case 'append':
      this.container.appendChild(this.makeNode(c.child).el)
      return
    case 'insert':
      this.container.insertBefore(this.makeNode(c.child).el, this.container.childNodes[c.index])
      return
    case 'replace':
      this.container.replaceChild(this.makeNode(c.child).el, this.tree.nodes.get(c.old).detach().el)
      return
    case 'replaceWithAll':
      var f = document.createDocumentFragment()
      c.children.forEach(function(child) {
        f.appendChild(this.makeNode(child).el)
      }, this)
      this.container.replaceChild(f, this.tree.nodes.get(c.old).detach().el)
      return
    case 'remove':
      this.container.removeChild(this.tree.nodes.get(c.child).detach().el)
      return
    default:
      console.warn('unhandled change:', c)
  }
}

Node.prototype.detach = function() {
  this.model.unlisten('nameChange', this.updateName)
  this.model.unlisten('hiddenChange', this.updateHidden)
  this.tree.nodes.delete(this)
  this.parent.children.delete(this)
  return this
}

Node.prototype.toggle = function() {
  this.item.classList.toggle('open', this.open = !this.open)
  if (this.loaded || !this.open) {
    this.container.style.display = this.open ? '' : 'none'
    return
  }
  this.loaded = true
  this.children = new Set
  this.model.children.forEach(function(child) {
    var n = this.makeNode(child)
    this.container.appendChild(n.el)
    return n
  }, this)
}

Node.prototype.makeNode = function(child) {
  var n = new Node(this.tree, this, child)
  this.children.add(n)
  return n
}

property(Node.prototype, 'selected', {didSet: function(value) {
  this.item.classList.toggle('selected', !!value)
}})

module.exports = Node
